\chapter{Аналитическая часть}

В данном разделе будут описаны алгоритмы умножения матриц: стандартный, Винограда, Штрассена и оптимизация алгоритма Винограда.

\section{Стандартный алгоритм матричного умножения}

Пусть даны две матрицы A и B размерности $N \cdot P$ и $P \cdot M$ соответсвенно:

\begin{equation}
	A_{NP} = \begin{pmatrix}
		a_{11} & a_{12} & \ldots & a_{1m}\\
		a_{21} & a_{22} & \ldots & a_{2m}\\
		\vdots & \vdots & \ddots & \vdots\\
		a_{l1} & a_{l2} & \ldots & a_{lm}
	\end{pmatrix},
	\quad
	B_{PM} = \begin{pmatrix}
		b_{11} & b_{12} & \ldots & b_{1n}\\
		b_{21} & b_{22} & \ldots & b_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		b_{m1} & b_{m2} & \ldots & b_{mn}
	\end{pmatrix},
\end{equation}

Тогда матрица C размерностью N*M:

\begin{equation}
	C_{NM} = \begin{pmatrix}
		c_{11} & c_{12} & \ldots & c_{1n}\\
		c_{21} & c_{22} & \ldots & c_{2n}\\
		\vdots & \vdots & \ddots & \vdots\\
		c_{l1} & c_{l2} & \ldots & c_{ln}
	\end{pmatrix},
\end{equation}

в которой:

\begin{equation}
	\label{eq:M}
	c_{ij} =
	\sum_{r=1}^{P} a_{ir}b_{rj} \quad (i=\overline{1,N}; j=\overline{1,M})
\end{equation}

называется их произведением.

Для вычисления произведения двух матриц, каждая строка первой матрицы почленно умножается на каждый столбец второй, затем подсчитывается сумма таких произведений и записывается в соответствующий элемент результирующей матрицы \cite{alg}.

\section{Алгоритм Винограда умножения матриц}

Алгоритм Винограда — это алгоритм умножения матриц, который был разработан в 1960-х годах Виктором Виноградовым. Этот алгоритм позволяет сократить количество умножений при умножении двух матриц, что делает его более эффективным для больших матриц по сравнению с классическим методом умножения.

Основная идея алгоритма Винограда заключается в том, чтобы предварительно вычислить некоторые промежуточные значения и затем использовать их для вычисления конечного результата. Это позволяет уменьшить количество умножений.

Рассмотрим два вектора $V = (v_1, v_2, v_3, v_4)$ и $W = (w_1, w_2, w_3, w_4)$.

Их скалярное произведение равно: $V \cdot W = v_1w_1 + v_2w_2 + v_3w_3 + v_4w_4$, что эквивалентно (\ref{for:new}):
\begin{equation}
	\label{for:new}
	V \cdot W = (v_1 + w_2)(v_2 + w_1) + (v_3 + w_4)(v_4 + w_3) - v_1v_2 - v_3v_4 - w_1w_2 - w_3w_4.
\end{equation}

Выражение в правой части формулы \ref{for:new} допускает предварительную обработку: его части можно вычислить заранее и запомнить для каждой строки первой матрицы и для каждого
столбца второй, что позволяет выполнять для каждого элемента лишь первые два умножения и последующие пять сложений, а также дополнительно два сложения. При нечетном значении размера матрицы нужно дополнительно добавить произведения крайних элементов соответствующих строк и столбцов к результату \cite{alg}.

\section{Алгоритм Штрассена умножения матриц}

Алгоритм Штрассена работает с квадратными матрицами. На самом деле он настолько эффективен, что иногда разумно расширить матрицы до квадратных, и при этом он все равно дает выигрыш, превышающий расходы на введение дополнительных элементов.
Для умножения матриц алгоритм Штрассена использует семь формул. Эти формулы чрезвычайно неестественны и, к сожалению, в оригинальной статье Штрассена не объясняется, как он пришел к ним. Замечательно, что как сами формулы, так и их использование не требуют, чтобы умножение элементов матриц было коммутативным. Это означает, в частности, что сами эти элементы могут быть матрицами, а значит, алгоритм Штрассена можно применять рекурсивно. Вот формулы Штрассена:
\begin{equation}
	\label{eq:ST1}
	x_1 = (G_{1,1} + G_{2,2}) \cdot (H_{1,1} + H_{2,2})
\end{equation}
\begin{equation}
	\label{eq:ST2}
	x_2 = (G_{2,1} + G_{2,2}) \cdot H_{1,1}
\end{equation}
\begin{equation}
	\label{eq:ST3}
	x_3 = G_{1,1} \cdot (H_{1,2} - H_{2,2})
\end{equation}
\begin{equation}
	\label{eq:ST4}
	x_4 = G_{2,2} \cdot (H_{1,2} - H_{2,2})
\end{equation}
\begin{equation}
	\label{eq:ST5}
	x_5 = (G_{1,1} + G_{2,2}) \cdot H_{2,2}
\end{equation}
\begin{equation}
	\label{eq:ST6}
	x_6 = (G_{2,1} - G_{1,1}) \cdot (H_{1,1} + H_{1,2})
\end{equation}
\begin{equation}
	\label{eq:ST7}
	x_7 = (G_{2,1} - G_{2,2}) \cdot (H_{2,1} + H_{2,2})
\end{equation}

Теперь элементы матрицы R могут вычисляться по формулам:
\begin{equation}
	\label{eq:ST8}
	R_{1,1} = x_1 + x_4 - x_5 + x_7
\end{equation}
\begin{equation}
	\label{eq:ST9}
	R_{1,2} = x_3 + x_5
\end{equation}
\begin{equation}
	\label{eq:ST10}
	R_{2,1} = x_2 + x_4
\end{equation}
\begin{equation}
	\label{eq:ST11}
	R_{2,2} = x_1 + x_3 - x_2 + x_6
\end{equation}
На практике алгоритм Штрассена применяется редко: его использование требует аккуратного отслеживания рекурсии.\cite{alg2}.
\section{Оптимизация алгоритма Винограда умножения матриц}

Оптимизированная версия алгоритма Винограда \cite{alg} отличается:

\begin{itemize}
	\item замены операцию x = x + k на x += k;
	\item замены умножение на 2 на побитовый сдвиг;
	\item предвычисление некоторые слагаемые для алгоритма..
\end{itemize}

\section{Вывод}

Были изучены способы умножения матриц при помощи классического алгоритма, алгоритма Винограда и алгоритма Штрассена. Также была рассмотрена оптимизация алгоритма Винограда.